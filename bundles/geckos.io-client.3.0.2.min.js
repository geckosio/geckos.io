var geckos;(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>y});class n{fn;context;once;constructor(e,t,n=!1){this.fn=e,this.context=t,this.once=n}}const o=(e,t,o,s,r)=>{if("function"!=typeof o)throw new TypeError("The listener must be a function");const i=new n(o,s||e,r);return e._events.has(t)?e._events.get(t).fn?e._events.set(t,[e._events.get(t),i]):e._events.get(t).push(i):(e._events.set(t,i),e._eventsCount++),e},s=(e,t)=>{0==--e._eventsCount?e._events=new Map:e._events.delete(t)};class r{static get VERSION(){return"0.0.7"}_events=new Map;_eventsCount=0;eventNames(){return Array.from(this._events.keys())}listeners(e){const t=this._events.get(e);if(!t)return[];if(t.fn)return[t.fn];for(var n=0,o=t.length,s=new Array(o);n<o;n++)s[n]=t[n].fn;return s}listenerCount(e){const t=this._events.get(e);return t?t.fn?1:t.length:0}emit(e,...t){if(!this._events.has(e))return!1;const n=this._events.get(e);let o;if(n.fn)return n.once&&this.removeListener(e,n.fn,void 0,!0),n.fn.call(n.context,...t),!0;{const s=n.length;for(o=0;o<s;o++)n[o].once&&this.removeListener(e,n[o].fn,void 0,!0),n[o].fn.call(n[o].context,...t)}return!0}on(e,t,n){return o(this,e,t,n,!1)}once(e,t,n){return o(this,e,t,n,!0)}removeListener(e,t,n,o){if(!this._events.has(e))return this;if(!t)return s(this,e),this;const r=this._events.get(e);if(r.fn)r.fn!==t||o&&!r.once||n&&r.context!==n||s(this,e);else{for(var i=0,a=[],c=r.length;i<c;i++)(r[i].fn!==t||o&&!r[i].once||n&&r[i].context!==n)&&a.push(r[i]);a.length?this._events.set(e,1===a.length?a[0]:a):s(this,e)}return this}removeAllListeners(e){return e?this._events.delete(e)&&s(this,e):(this._events=new Map,this._eventsCount=0),this}get off(){return this.removeListener}get addListener(){return this.on}}class i{constructor(){this.eventEmitter=new r}emit(e,t,n={}){this.eventEmitter.emit(e,t,n)}on(e,t){return this.eventEmitter.on(e,((e,n)=>{t(e,n)}))}removeAllListeners(){this.eventEmitter.removeAllListeners()}}new i;const a="disconnected",c="rawMessage",l="BROWSER_NOT_SUPPORTED",h="COULD_NOT_PARSE_MESSAGE",d=Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array)).constructor,u=("function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=>"string"==typeof e),f=e=>e instanceof ArrayBuffer||e instanceof d,g=e=>{let{data:t}=e;t||(t=e);const n=f(t),o=(e=>{try{return"string"==typeof e&&!!isNaN(parseInt(e))&&(JSON.parse(e),!0)}catch(e){return!1}})(t),s=u(t);if(o){const e=JSON.parse(t),n=Object.keys(e)[0];return{key:n,data:e[n]}}return n||s?{key:c,data:t}:{key:"error",data:new Error(h)}};class v{emit(e,t=null){((e,t,n,o=null)=>{var s;const r=(n,o)=>{var s;const r=null!==(s=n.byteLength)&&void 0!==s?s:2*n.length;if("number"==typeof t&&r>t)throw new Error(`maxMessageSize of ${t} exceeded`);Promise.resolve().then((()=>{e.send?e.send(n):o?e.sendMessageBinary(Buffer.from(n)):e.sendMessage(n)})).catch((e=>{console.log("error",e)}))};if(e&&("open"===e.readyState||(null===(s=e.isOpen)||void 0===s?void 0:s.call(e))))try{n===c&&null!==o&&(u(o)||f(o))?r(o,f(o)):r(JSON.stringify({[n]:o}),!1)}catch(e){return console.error("Error in sendMessage.ts: ",e.message),e}})(this.dataChannel,this.maxMessageSize,e,t)}constructor(e,t,n,o){this.url=e,this.authorization=t,this.label=n,this.rtcConfiguration=o,this.bridge=new i,this.onDataChannel=e=>{const{channel:t}=e;t.label===this.label&&(this.dataChannel=t,this.dataChannel.binaryType="arraybuffer",this.dataChannel.onmessage=e=>{const{key:t,data:n}=g(e);this.bridge.emit(t,n)})}}async fetchAdditionalCandidates(e,t){var n;if("closed"===(null===(n=this.dataChannel)||void 0===n?void 0:n.readyState))return;const o=await fetch(`${e}/connections/${t}/additional-candidates`,{method:"GET",headers:{"Content-Type":"application/json"}});if(o.ok){(await o.json()).forEach((e=>{this.localPeerConnection.addIceCandidate(e)}))}}async connect(){const e=`${this.url}/.wrtc/v2`;let t={"Content-Type":"application/json"};this.authorization&&(t={...t,Authorization:this.authorization});let n={};try{const o=await fetch(`${e}/connections`,{method:"POST",headers:t});if(o.status>=300)throw{name:"Error",message:`Connection failed with status code ${o.status}.`,status:o.status,statusText:o.statusText};const s=await o.json();n=s.userData,this.remotePeerConnection=s}catch(e){return console.error(e.message),{error:e}}const{id:o,localDescription:s}=this.remotePeerConnection,r={sdpSemantics:"unified-plan",...this.rtcConfiguration},i=RTCPeerConnection||webkitRTCPeerConnection;this.localPeerConnection=new i(r);((e=10,t=50,n=1.8,o=20)=>Array(e).fill(0).map(((e,s)=>parseInt((t*n**s).toString())+parseInt((Math.random()*o).toString()))))().forEach((t=>{setTimeout((()=>{this.fetchAdditionalCandidates(e,o).catch((()=>{}))}),t)}));try{await this.localPeerConnection.setRemoteDescription(s),this.localPeerConnection.addEventListener("datachannel",this.onDataChannel,{once:!0});const t=await this.localPeerConnection.createAnswer(),r=new RTCSessionDescription({type:"answer",sdp:t.sdp});await this.localPeerConnection.setLocalDescription(r);try{await fetch(`${e}/connections/${o}/remote-description`,{method:"POST",body:JSON.stringify(this.localPeerConnection.localDescription),headers:{"Content-Type":"application/json"}})}catch(e){return console.error(e.message),{error:e}}const i=()=>new Promise((e=>{this.localPeerConnection.addEventListener("datachannel",(()=>{e()}),{once:!0})}));return this.dataChannel||await i(),{userData:n,localPeerConnection:this.localPeerConnection,dataChannel:this.dataChannel,id:o}}catch(e){return console.error(e.message),this.localPeerConnection.close(),{error:e}}}}class m{async connect(e){if(RTCPeerConnection||webkitRTCPeerConnection){const{localPeerConnection:t,dataChannel:n,id:o,userData:s,error:r}=await e.connect();return r?{error:r}:t&&n&&o&&s?(this.localPeerConnection=t,this.dataChannel=n,this.id=o,{userData:s}):{error:new Error('Something went wrong in "await connectionsManager.connect()"')}}{const e=new Error(l);return console.error(e.message),{error:e}}}}const p=(e,t)=>{const{interval:n=150,runs:o=10}=e,s=((e=24)=>{const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";let n="";for(let o=0;o<e;o++)n+=t.charAt(Math.floor(62*Math.random()));return n})(24);((e=200,t=1,n)=>{let o=0;if("function"!=typeof n)return void console.error("You have to define your callback function!");const s=setInterval((()=>{n(),o++,o===t-1&&clearInterval(s)}),e);n()})(n,o,(()=>{t(s)}))};class C{constructor(e,t,n,o,s){this.userData={},this.receivedReliableMessages=[],this.url=n?`${e}:${n}`:e,this.connectionsManager=new v(this.url,t,o,s),this.bridge=this.connectionsManager.bridge,this.bridge.on(a,(()=>this.bridge.removeAllListeners()))}onconnectionstatechange(){const e=this.peerConnection.localPeerConnection;e.onconnectionstatechange=()=>{"disconnected"!==e.connectionState&&"closed"!==e.connectionState||this.bridge.emit(a)}}get id(){return this.peerConnection.id}close(){this.peerConnection.localPeerConnection.close(),this.bridge.emit(a);try{const e=`${this.url}/.wrtc/v2`;fetch(`${e}/connections/${this.id}/close`,{method:"POST",headers:{"Content-Type":"application/json"}})}catch(e){console.error(e.message)}}emit(e,t=null,n){n&&n.reliable?p(n,(n=>this.connectionsManager.emit(e,{MESSAGE:t,RELIABLE:1,ID:n}))):this.connectionsManager.emit(e,t)}get raw(){return{emit:e=>this.emit(c,e)}}onRaw(e){this.bridge.on(c,(t=>{(t=>{e(t)})(t)}))}async onConnect(e){var t;this.peerConnection=new m;const n=await this.peerConnection.connect(this.connectionsManager);n.error?e(n.error):(n.userData&&(this.userData=n.userData),this.maxMessageSize=this.connectionsManager.maxMessageSize=null===(t=this.peerConnection.localPeerConnection.sctp)||void 0===t?void 0:t.maxMessageSize,this.onconnectionstatechange(),e())}onDisconnect(e){this.bridge.on(a,e)}on(e,t){this.bridge.on(e,(e=>{e&&1===e.RELIABLE&&"undefined"!==e.ID?((()=>{const e=(new Date).getTime();this.receivedReliableMessages.forEach(((t,n,o)=>{t.expire<=e&&o.splice(n,1)}))})(),0===this.receivedReliableMessages.filter((t=>t.id===e.ID)).length&&(this.receivedReliableMessages.push({id:e.ID,timestamp:new Date,expire:(new Date).getTime()+15e3}),t(e.MESSAGE))):t(e)}))}}const y=(e={})=>{const{authorization:t,iceServers:n=[],iceTransportPolicy:o="all",label:s="geckos.io",port:r=9208,url:i=`${location.protocol}//${location.hostname}`}=e;return new C(i,t,r,s,{iceServers:n,iceTransportPolicy:o})};geckos=t.default})();